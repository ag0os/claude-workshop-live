#!/usr/bin/env bun
import { readdir } from "node:fs/promises";
import { writeFile } from "node:fs/promises";
import { join } from "node:path";

const ROOT = process.cwd();
const outPath = join(ROOT, "lib", "assets.gen.ts");

function toVar(prefix: string, key: string) {
  return (
    prefix +
    "_" +
    key
      .replace(/\.[^/.]+$/, "")
      .replace(/[^a-zA-Z0-9]+/g, "_")
      .replace(/^([0-9])/, "_$1")
  );
}

function baseFrom(filename: string, pattern: RegExp): string | null {
  const m = filename.match(pattern);
  return m ? m[1] : null;
}

async function main() {
  const sysDir = join(ROOT, "system-prompts");
  const promptsDir = join(ROOT, "prompts");
  const settingsDir = join(ROOT, "settings");

  const sysFiles = await readdir(sysDir).catch(() => []);
  const promptFiles = await readdir(promptsDir).catch(() => []);
  const settingsFiles = await readdir(settingsDir).catch(() => []);

  type Item = { base: string; path: string; var: string };

  const sysItems: Item[] = sysFiles
    .filter((f) => f.endsWith(".md"))
    .map((f) => ({ f, base: baseFrom(f, /^(.*)-prompt\.md$/) }))
    .filter((x): x is { f: string; base: string } => Boolean(x.base))
    .map(({ f, base }) => ({ base, path: `../system-prompts/${f}`, var: toVar("SP", base) }));

  const promptItems: Item[] = promptFiles
    .filter((f) => f.endsWith(".md"))
    .map((f) => ({ base: baseFrom(f, /^(.*)\.md$/), f }))
    .filter((x): x is { f: string; base: string } => Boolean(x.base))
    .map(({ f, base }) => ({ base, path: `../prompts/${f}`, var: toVar("PR", base) }));

  const settingsItems: Item[] = settingsFiles
    .filter((f) => f.endsWith(".settings.json"))
    .map((f) => ({ base: baseFrom(f, /^(.*)\.settings\.json$/), f }))
    .filter((x): x is { f: string; base: string } => Boolean(x.base))
    .map(({ f, base }) => ({ base, path: `../settings/${f}`, var: toVar("ST", base) }));

  const mcpItems: Item[] = settingsFiles
    .filter((f) => f.endsWith(".mcp.json"))
    .map((f) => ({ base: baseFrom(f, /^(.*)\.mcp\.json$/), f }))
    .filter((x): x is { f: string; base: string } => Boolean(x.base))
    .map(({ f, base }) => ({ base, path: `../settings/${f}`, var: toVar("MCP", base) }));

  const lines: string[] = [];
  lines.push("// This file is generated by scripts/gen-assets.ts. Do not edit.");
  lines.push("// It contains static imports so Bun can inline all assets.");
  lines.push("");

  for (const it of sysItems) {
    lines.push(`import ${it.var} from '${it.path}' with { type: 'text' }`);
  }
  for (const it of promptItems) {
    lines.push(`import ${it.var} from '${it.path}' with { type: 'text' }`);
  }
  for (const it of settingsItems) {
    lines.push(`import ${it.var} from '${it.path}' with { type: 'json' }`);
  }
  for (const it of mcpItems) {
    lines.push(`import ${it.var} from '${it.path}' with { type: 'json' }`);
  }

  function emitMap(name: string, items: Item[]) {
    lines.push(`export const ${name} = {`);
    const rows = items
      .map((it) => `  '${it.base}': ${it.var}`)
      .sort();
    for (let i = 0; i < rows.length; i++) {
      const sep = i === rows.length - 1 ? "" : ",";
      lines.push(rows[i] + sep);
    }
    lines.push(`};`);
  }

  lines.push("");
  emitMap("SYSTEM_PROMPTS", sysItems);
  emitMap("PROMPTS", promptItems);
  emitMap("SETTINGS", settingsItems);
  emitMap("MCP", mcpItems);

  await writeFile(outPath, lines.join("\n") + "\n", "utf8");
}

await main();
